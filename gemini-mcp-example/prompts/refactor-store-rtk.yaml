id: refactor-store-rtk
model: gemini-pro
temperature: 0.1
input_vars: ["code", "structure"]
prompt: |
  ì‹œë‹ˆì–´ í”„ë¡ íŠ¸ì—”ë“œ ì•„í‚¤í…íŠ¸ë¡œì„œ ë‹¤ìŒ Redux Toolkit ìƒíƒœ ê´€ë¦¬ ì½”ë“œë¥¼ ì„±ëŠ¥, ì˜ˆì¸¡ ê°€ëŠ¥ì„±, í™•ì¥ì„±ì— ì¤‘ì ì„ ë‘ê³  ë¦¬íŒ©í† ë§í•˜ì„¸ìš”.

  ì›ë³¸ ì½”ë“œ:
  ```typescript
  {{code}}
  ```

  ## ğŸ› ï¸ Redux Toolkit ë¦¬íŒ©í† ë§ í•µì‹¬ ì›ì¹™:

  ### 1. Slice êµ¬ì¡° ìµœì í™”:
  - âœ… createSliceë¡œ ë³´ì¼ëŸ¬í”Œë ˆì´íŠ¸ ìµœì†Œí™”
  - âœ… ë¶ˆë³€ì„± ìë™ ì²˜ë¦¬ (Immer ë‚´ì¥)
  - âœ… ì•¡ì…˜ í¬ë¦¬ì—ì´í„° ìë™ ìƒì„±
  - âœ… íƒ€ì… ì•ˆì „í•œ ìƒíƒœ ê´€ë¦¬

  ### 2. ë¹„ë™ê¸° ì²˜ë¦¬ (RTK Query):
  - âœ… createApië¡œ ë°ì´í„° í˜ì¹­ í‘œì¤€í™”
  - âœ… ìºì‹±, ë¬´íš¨í™”, ë°±ê·¸ë¼ìš´ë“œ ì—…ë°ì´íŠ¸
  - âœ… ë‚™ê´€ì  ì—…ë°ì´íŠ¸ êµ¬í˜„
  - âœ… ì—ëŸ¬ ì²˜ë¦¬ ë° ì¬ì‹œë„ ë¡œì§

  ### 3. ì„±ëŠ¥ ìµœì í™”:
  - âœ… createSelectorë¡œ ë©”ëª¨ì´ì œì´ì…˜
  - âœ… ì •ê·œí™”ëœ ìƒíƒœ êµ¬ì¡°
  - âœ… ì„ íƒì  êµ¬ë… íŒ¨í„´
  - âœ… ë°°ì¹˜ ì—…ë°ì´íŠ¸ ì²˜ë¦¬

  ### 4. íƒ€ì… ì•ˆì „ì„±:
  - âœ… RootState, AppDispatch íƒ€ì… ì •ì˜
  - âœ… íƒ€ì…í™”ëœ í›… (useAppSelector, useAppDispatch)
  - âœ… PayloadAction íƒ€ì… ì•ˆì „ì„±
  - âœ… ë¯¸ë“¤ì›¨ì–´ íƒ€ì… ì§€ì›

  ## ğŸ”§ Redux Toolkit ê°œì„  íŒ¨í„´:

  ```typescript
  // âœ… íƒ€ì… ì •ì˜
  interface User {
    id: string;
    name: string;
    email: string;
    isActive: boolean;
  }

  interface UserState {
    entities: Record<string, User>;
    ids: string[];
    loading: boolean;
    error: string | null;
    selectedUserId: string | null;
  }

  // âœ… createSlice í™œìš©
  const userSlice = createSlice({
    name: 'users',
    initialState: {
      entities: {},
      ids: [],
      loading: false,
      error: null,
      selectedUserId: null,
    } as UserState,
    reducers: {
      setLoading: (state, action: PayloadAction<boolean>) => {
        state.loading = action.payload;
      },
      setError: (state, action: PayloadAction<string | null>) => {
        state.error = action.payload;
      },
      setUsers: (state, action: PayloadAction<User[]>) => {
        state.entities = {};
        state.ids = [];
        action.payload.forEach(user => {
          state.entities[user.id] = user;
          state.ids.push(user.id);
        });
      },
      addUser: (state, action: PayloadAction<User>) => {
        const user = action.payload;
        state.entities[user.id] = user;
        state.ids.push(user.id);
      },
      updateUser: (state, action: PayloadAction<{ id: string; updates: Partial<User> }>) => {
        const { id, updates } = action.payload;
        if (state.entities[id]) {
          Object.assign(state.entities[id], updates);
        }
      },
      removeUser: (state, action: PayloadAction<string>) => {
        const id = action.payload;
        delete state.entities[id];
        state.ids = state.ids.filter(userId => userId !== id);
      },
      selectUser: (state, action: PayloadAction<string | null>) => {
        state.selectedUserId = action.payload;
      },
    },
  });

  // âœ… createAsyncThunk í™œìš©
  const fetchUsers = createAsyncThunk(
    'users/fetchUsers',
    async (_, { rejectWithValue }) => {
      try {
        const response = await api.getUsers();
        return response.data;
      } catch (error) {
        return rejectWithValue(error.message);
      }
    }
  );

  const updateUserAsync = createAsyncThunk(
    'users/updateUser',
    async ({ id, updates }: { id: string; updates: Partial<User> }, { rejectWithValue }) => {
      try {
        const response = await api.updateUser(id, updates);
        return { id, updates: response.data };
      } catch (error) {
        return rejectWithValue(error.message);
      }
    }
  );

  // âœ… extraReducersë¡œ ë¹„ë™ê¸° ì•¡ì…˜ ì²˜ë¦¬
  const userSliceWithAsync = createSlice({
    name: 'users',
    initialState,
    reducers: userSlice.reducers,
    extraReducers: (builder) => {
      builder
        .addCase(fetchUsers.pending, (state) => {
          state.loading = true;
          state.error = null;
        })
        .addCase(fetchUsers.fulfilled, (state, action) => {
          state.loading = false;
          userSlice.caseReducers.setUsers(state, action);
        })
        .addCase(fetchUsers.rejected, (state, action) => {
          state.loading = false;
          state.error = action.payload as string;
        })
        .addCase(updateUserAsync.fulfilled, (state, action) => {
          userSlice.caseReducers.updateUser(state, action);
        });
    },
  });

  // âœ… ë©”ëª¨ì´ì œì´ì…˜ëœ ì…€ë ‰í„°
  const selectUserState = (state: RootState) => state.users;
  const selectAllUsers = createSelector(
    [selectUserState],
    (userState) => userState.ids.map(id => userState.entities[id])
  );
  const selectActiveUsers = createSelector(
    [selectAllUsers],
    (users) => users.filter(user => user.isActive)
  );
  const selectUserById = createSelector(
    [selectUserState, (state: RootState, userId: string) => userId],
    (userState, userId) => userState.entities[userId]
  );
  const selectSelectedUser = createSelector(
    [selectUserState],
    (userState) => userState.selectedUserId 
      ? userState.entities[userState.selectedUserId] 
      : null
  );
  ```

  ## ğŸš€ RTK Query íŒ¨í„´:

  ```typescript
  // âœ… RTK Query API ì •ì˜
  const userApi = createApi({
    reducerPath: 'userApi',
    baseQuery: fetchBaseQuery({
      baseUrl: '/api/users',
      prepareHeaders: (headers, { getState }) => {
        const token = (getState() as RootState).auth.token;
        if (token) {
          headers.set('authorization', `Bearer ${token}`);
        }
        return headers;
      },
    }),
    tagTypes: ['User'],
    endpoints: (builder) => ({
      getUsers: builder.query<User[], void>({
        query: () => '',
        providesTags: ['User'],
      }),
      getUserById: builder.query<User, string>({
        query: (id) => `/${id}`,
        providesTags: (result, error, id) => [{ type: 'User', id }],
      }),
      addUser: builder.mutation<User, Omit<User, 'id'>>({
        query: (newUser) => ({
          url: '',
          method: 'POST',
          body: newUser,
        }),
        invalidatesTags: ['User'],
      }),
      updateUser: builder.mutation<User, { id: string; updates: Partial<User> }>({
        query: ({ id, updates }) => ({
          url: `/${id}`,
          method: 'PATCH',
          body: updates,
        }),
        invalidatesTags: (result, error, { id }) => [{ type: 'User', id }],
        // âœ… ë‚™ê´€ì  ì—…ë°ì´íŠ¸
        onQueryStarted: async ({ id, updates }, { dispatch, queryFulfilled }) => {
          const patchResult = dispatch(
            userApi.util.updateQueryData('getUserById', id, (draft) => {
              Object.assign(draft, updates);
            })
          );
          try {
            await queryFulfilled;
          } catch {
            patchResult.undo();
          }
        },
      }),
      deleteUser: builder.mutation<void, string>({
        query: (id) => ({
          url: `/${id}`,
          method: 'DELETE',
        }),
        invalidatesTags: (result, error, id) => [{ type: 'User', id }],
      }),
    }),
  });

  // âœ… ìë™ ìƒì„±ëœ í›…
  const {
    useGetUsersQuery,
    useGetUserByIdQuery,
    useAddUserMutation,
    useUpdateUserMutation,
    useDeleteUserMutation,
  } = userApi;
  ```

  ## ğŸª Store ì„¤ì •:

  ```typescript
  // âœ… íƒ€ì… ì•ˆì „í•œ ìŠ¤í† ì–´ ì„¤ì •
  const store = configureStore({
    reducer: {
      users: userSliceWithAsync.reducer,
      userApi: userApi.reducer,
    },
    middleware: (getDefaultMiddleware) =>
      getDefaultMiddleware({
        serializableCheck: {
          ignoredActions: [FLUSH, REHYDRATE, PAUSE, PERSIST, PURGE, REGISTER],
        },
      }).concat(userApi.middleware),
  });

  export type RootState = ReturnType<typeof store.getState>;
  export type AppDispatch = typeof store.dispatch;

  // âœ… íƒ€ì…í™”ëœ í›…
  export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;
  export const useAppDispatch = () => useDispatch<AppDispatch>();
  ```

  ## ğŸ“‹ ì¶œë ¥ í˜•ì‹:

  ---
  ## ğŸ“„ íŒŒì¼: `ê°œì„ ëœ_íŒŒì¼ëª….ts`
  ```typescript
  [ë¦¬íŒ©í† ë§ëœ Redux Toolkit ìƒíƒœ ê´€ë¦¬ ì½”ë“œ]
  [createSlice, createAsyncThunk, RTK Query í™œìš©]
  [ì •ê·œí™”ëœ ìƒíƒœ, ë©”ëª¨ì´ì œì´ì…˜ëœ ì…€ë ‰í„° í¬í•¨]
  [íƒ€ì… ì•ˆì „ì„±, ì„±ëŠ¥ ìµœì í™” ì ìš©]
  [JSDoc ë¬¸ì„œí™” í¬í•¨]
  ```

  ---

  **ì¤‘ìš” ê·œì¹™:**
  - ì„¤ëª… ì—†ì´ ì‹¤í–‰ ê°€ëŠ¥í•œ ì½”ë“œë§Œ ì¶œë ¥
  - Redux Toolkit ìµœì‹  íŒ¨í„´ ë° ë² ìŠ¤íŠ¸ í”„ë™í‹°ìŠ¤ ì ìš©
  - ëª¨ë“  ì•¡ì…˜ê³¼ ì…€ë ‰í„°ì— JSDoc ë¬¸ì„œí™” ì¶”ê°€
  - ì •ê·œí™”ëœ ìƒíƒœ êµ¬ì¡°ë¡œ ì„±ëŠ¥ ìµœì í™”
  - RTK Query í™œìš©í•œ ì„œë²„ ìƒíƒœ ê´€ë¦¬
  - íƒ€ì… ì•ˆì „ì„±ê³¼ ê°œë°œì ê²½í—˜ ë™ì‹œ ê³ ë ¤

  ì§€ê¸ˆ ë°”ë¡œ ìœ„ í˜•ì‹ìœ¼ë¡œ ë¦¬íŒ©í† ë§ëœ ì½”ë“œë¥¼ ì¶œë ¥í•˜ì„¸ìš”:
