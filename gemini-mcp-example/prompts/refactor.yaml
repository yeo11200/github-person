id: refactor
model: gemini-pro
temperature: 0.1
input_vars: ["code", "structure"]
prompt: |
  10년차 시니어 프론트엔드 아키텍트로서 다음 코드를 컴포넌트 폴더 컨벤션에 맞게 완전히 리팩토링하세요.

  원본 코드:
  ```tsx
  {{code}}
  ```

  ## 🏗️ 필수 컴포넌트 폴더 컨벤션:
  ```
  ComponentName/
  ├── hooks/
  │   └── useComponentName.ts    # 모든 비즈니스 로직
  ├── ComponentName.tsx          # 순수 UI 컴포넌트
  └── index.ts                   # Barrel export
  ```

  ## 🎯 리팩토링 전략:
  1. **완전한 로직 분리**: 모든 상태/핸들러를 `hooks/useComponentName.ts`로 분리
  2. **순수 UI 컴포넌트**: 컴포넌트는 커스텀 훅 import 후 렌더링만
  3. **성능 최적화**: React.memo, useCallback, useMemo 정확한 원칙으로 적용
  4. **내부 컴포넌트 분리**: 반복되는 JSX를 별도 컴포넌트로 추출
  5. **TypeScript 강화**: 인터페이스와 타입 안전성

  ## ⚡ React 성능 최적화 핵심 원칙:

  ### useCallback 사용 시점 (정확한 원칙):
  - ✅ **자식 컴포넌트에 함수를 props로 넘길 때**
  - ✅ **useEffect 등 의존성으로 함수를 넣어야 할 때**
  - ✅ **이벤트 핸들러가 자주 재생성되어 성능 이슈가 있을 때**
  - ❌ 단순히 컴포넌트 내부에서만 사용하는 함수는 불필요

  ### useMemo 사용 시점 (정확한 원칙):
  - ✅ **무거운 계산 결과를 캐싱할 때**
  - ✅ **자식 컴포넌트에 객체/배열을 props로 넘길 때**
  - ✅ **useEffect 의존성으로 객체/배열을 넣어야 할 때**
  - ❌ 단순한 문자열이나 숫자 계산은 불필요

  ### React.memo 사용 시점:
  - ✅ **props가 자주 변경되지 않는 컴포넌트**
  - ✅ **렌더링 비용이 높은 컴포넌트**
  - ✅ **부모가 자주 리렌더링되는 자식 컴포넌트**

  ## 🔧 구체적인 적용 예시:

  ```tsx
  // ✅ 올바른 useCallback 사용
  const handleClick = useCallback(() => {
    doSomething();
  }, [dependency]); // 자식에게 props로 전달하거나 useEffect 의존성일 때

  // ✅ 올바른 useMemo 사용
  const expensiveValue = useMemo(() => {
    return heavyCalculation(data);
  }, [data]); // 무거운 계산이거나 자식에게 전달할 객체/배열

  // ❌ 불필요한 useCallback
  const simpleHandler = () => console.log('click'); // 내부에서만 사용

  // ❌ 불필요한 useMemo
  const simpleValue = useMemo(() => a + b, [a, b]); // 단순 계산
  ```

  ## 📋 출력 형식 (정확히 이 구조로):

  ---
  ## 📄 파일: `hooks/useComponentName.ts`
  ```tsx
  [커스텀 훅 코드 - 모든 비즈니스 로직 포함]
  [올바른 useCallback/useMemo 원칙 적용]
  ```

  ---
  ## 📄 파일: `ComponentName.tsx`  
  ```tsx
  [순수 UI 컴포넌트 코드 - 커스텀 훅 import하여 사용]
  [React.memo 적용 및 성능 최적화]
  ```

  ---

  **중요 규칙:**
  - 설명 없이 실행 가능한 코드만 출력
  - 각 파일을 명확히 구분하여 표시
  - 모든 주석은 한국어로 작성
  - 원본 기능을 모두 유지하면서 개선
  - useCallback/useMemo는 정확한 원칙에 따라서만 사용

  지금 바로 위 형식으로 리팩토링된 코드를 출력하세요:
